---
title: "MIDTERNONWARD"
output: html_document
---

R times Web Scraper

```{r, eval=FALSE}
Sys.setenv(NYTIMES_AS_KEY = "b4969dfbe67548568bf022335e4bd5fb")
  
bit <- as_search(q="bitcoin", begin_date = "20100101", end_date = '20180401', all_results = TRUE)  

crypt <- as_search(q="cryptocurrency", begin_date = "20100101", end_date = '20180401', all_results = TRUE)  
```

bitcoin yields more data points (1154 to cryto's 125)

want to use sentiment analysis to rate headlines

bring in tm_cleaner function

```{r}
tm_cleaner <- function(corpus, stop=stopwords("en"), rm_num=TRUE) {
  require(tm)
  corpus <- tm_map(corpus, stripWhitespace)
  corpus <- tm_map(corpus, removeNumbers)
  corpus <- tm_map(corpus, content_transformer(tolower))
  corpus <- tm_map(corpus, removeWords, stop)
  corpus <- tm_map(corpus, removePunctuation)
  corpus <- tm_map(corpus, content_transformer(function(x) gsub("http\\w+", "", x)))
  return(corpus)
}

```

created function to generate dataframes of sentiment analysis with diffrent dictionarys
where 
"dataNYT" is a dataframe generated from rtimes. 

```{r}
sentimentoutput <- function(dataNYT)  {
  
library(rvest)
library(SentimentAnalysis)
library(stringr)
library(dplyr)
library(tm)

data <-  dataNYT$data   
  
headlines <- data$headline.main

headlinecorpus <- Corpus(VectorSource(headlines))

headlineclean <- tm_cleaner(headlinecorpus)

sentimentnum <- analyzeSentiment(headlineclean)

GI <-convertToBinaryResponse(sentimentnum$SentimentGI)
LM <-convertToBinaryResponse(sentimentnum$SentimentLM)
QDAP <-convertToBinaryResponse(sentimentnum$SentimentQDAP)

headlineoriginal <- factor(data$headline.main)

GI_num <- ifelse(GI =="positive",1,-1) 
LM_num <- ifelse(LM =="positive",1,-1) 
QDAP_num <- ifelse(QDAP =="positive",1,-1) 

analysis <- data.frame(Score=factor(GI_num + LM_num + QDAP_num),
  GI=factor(GI),
  LM=factor(LM),
  QDAP=factor(QDAP),
  Headline=factor(data$headline.main),
  date=as.Date(data$pub_date),
  stringsAsFactors=FALSE)

return(analysis)

}

```

Have a score in this set, to factor in responses from all dictionaries 


```{r}
bitdata <- sentimentoutput(bit)

cryptdata <- sentimentoutput(crypt)

```

Looking at the data, there are a number of headlines that dont seem to have much to do with bitcoin or crypto currency. will delete rows if no string of bitcoin and cryptocurrency exist

```{r}

library(stringr)
library(dplyr)
cleanbit <- bitdata %>%
  filter(str_detect(Headline, "Bitcoin"))

cleancrypt <- cryptdata %>%
  filter(str_detect(Headline, "Cryptocurrencies"))
```

will graph this data see what we find

```{r}
library(ggplot2)
ggplot(cleanbit) + 
  geom_point(aes(x=date, y=Score)) 

```

There appears to be a high amount of "good" headlines concerning bitcoin (scores of three). This seems to be promising coorelating with the increse in market vaule, but I would like to create some kind of density graph so we can see where media coverage was at its highest.

```{r}
library(dplyr)
table <- cleanbit %>%
  group_by(date) %>%
  summarise (n = n())
```

```{r}
ggplot(table) + geom_density(aes(date))
```

it seems NYT intrest peaked around early 2014. 

plotting bitcoin again

```{r}
alldata$date <- as.Date(alldata$date,"%m/%d/%Y")

ggplot(subset(alldata,slug %in% c("bitcoin"))) + 
  geom_line(aes(x=date, y=close)) 

```


Peform the following to get a table that shows the aggregate score for each date. 

```{r}
library(tidyr)
library(dplyr)
library(plyr)

cleanbit$Score <- as.numeric(as.character(cleanbit$Score))

cleanbitagg<- ddply(cleanbit,.(date),summarize,sum=sum(Score),number=length(id))
```


grapghing the aggregate scores

```{r}
library(ggplot2)
ggplot(cleanbitagg) + geom_point(aes(x=date,y=sum))

```


let me create a function that i can drop any rtimes file into to rate and aggregate 

"analyze" is a dataset generated from previous "sentiment output"" function
"word" is a chracter string that if a row doesnt not contain, it is deleted

```{r}
aggregatescore <- function(analyze,word) {
library(stringr)
library(dplyr)
clean <- analyze %>%
  filter(str_detect(Headline, word))

table <- clean %>%
  group_by(date) %>%
  summarise (n = n())
  
library(tidyr)
library(plyr)

clean$Score <- as.numeric(as.character(clean$Score))

cleanagg<- ddply(cleanbit,.(date),summarize,sum=sum(Score),number=length(id))  

return(cleanagg)  
  
}


```

```{r}
cleanbitagg <- aggregatescore(bitdata,"bitcoin")
```



